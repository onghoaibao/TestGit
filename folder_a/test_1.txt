I. Questions
1. How does a compiler process #include directive?
Trl: ghép thêm mã nguồn của 1 tiệp header file vào mã nguồn cần dịch

2. Approximately what is the line #include <stdio.h> at the top of a C source file for?
Tr: sao chép nội dung của thư viện <stdio.h> trong C vào đầu Ctr chính.

3. What are the largest and smallest values that can be reliably stored in a variable of type int?
Trl: Giá trị của kiểu int còn phụ thuộc vào hệ điều hành. với 32bit hay 64bit điều là 4 byte 


4. What is the difference between the constants 7, '7', and "7"?
Trl: kiểm tra các Constans trong bảng mã ASCII với 7 là số, '7' là ký số, "7" cũng là ký số.
nhưng đối với "7" là đang ở dạng chuỗi còn '7' dnagj ký tự.
 
5. What is the correct output from the following code?
    #include <stdio.h>
    int main(int argc, char** argv) {
       int x = 3;
       printf("%d", x++  +  ++x); // x++ ko tang tron 1 cai lenh, ++x tang trong dong lenh dang chay=> x++(3) + ++x(4) = 7
       return 1;
    }
    Trl: x = 8; in a statement x++ is increase 1

6. What will the following code do?
    int main(int argc, char** argv) {
       char* ptr = NULL;
       free(ptr);
       return 0;
    }
Trl: Vì ptr là con trỏ Null nên  hàm free(ptr) sẽ không diễn ra, vì hàm free() chỉ sự dụng cho việc thu hồi cấp phát bộ nhớ động.
ptr được khái báo trong hàm Main nên nó sẽ nằm ở stack, khi ra khỏi hàm thì nó sẽ tự giải phóng, hàm free() thu hồi trên heap.

7. What will happen if we run the following function?
    void cool() {
        cool();
    }
Trl: Tràng Stack, vì hàm đệ qui trực tiếp ko có đk dừng nên có thể xem nó như 1 vòng cool() được thực hiên liên tục mà ko dc giải phóng 

8. Why do we need to put a declaration of a function in a header file?
Trl: Khai báo nguyên mẫu hàm, cũng giống như việc chép toàn bộ nội dung của hàm đó lên trên hàm chính. 
Quá trình build code sẽ build từ các header file sao đó đến cái hàm con, tránh việc build Hàm đó nếu ko sữa nội dung.

9. What are the differences between malloc and calloc?
Trl: 
- Hàm malloc() cấp phát vùng nhớ cho con trỏ với giá trị đầu là rac
- Ham calloc() cấp phát vùng nhớ cho con tro với giá trị đầu là 0.
- Thông thường hàm calloc() sẽ chậm hơn hàm malloc(), lý do là nó còn phải gán giá trị cho tất cả các phần tử của vùng nhớ vừa cấp phát = 0
- độ an toàn: trên malloc() vì mới cấp phát nó chứa các giá trị rác, nên có thể sẽ bị lỗi nếu truy xuất tới vùng nhớ này.
   
10. What is assert? Do we need it?
Trl: trong header file assert.h của C cung cap 1 macro, dùng để tìm lỗi trong C 

11. What are those file: .h .c .s .o .so .a? How do they fit into the C compilation process?
Trl: 
- .h là header file chứa các nguyên mẫu hàm
- .c là file source code
- .s là sau khi biên dịch qua compiler
- .o là sau khi biên dịch qua Assempler.
- .so là file thư viện liên kết động
- .a là file thư viện liên kết tĩnh 

12. What are the differences between some code snippets below?
struct Cool {
    int num;
};
Trl: kiểu cấu trúc không có biến cấu trúc, khi khai báo cần thêm từ khóa struct Cool c1,c2; 

struct Cool {
    int num;
} cool;
Trl: kiểu cấu trúc có biến cấu trúc là cool.


struct {
    int num;
} cool;
Trl: kiểu cấu trúc này không tên cấu trúc, kiểu này chỉ có thể sử dụng cool làm biến cấu trúc và không thể
khai báo thêm biến cấu trúc trong hàm.

typedef struct _Cool {
    int num;
} Cool;
Trl: ham cau truc duoc dinh nghia voi 1 ten moi Cool khi khai bao bien cau truc chi can: Cool [ten_bien]; thay vi struct _Cool [ten_bien];

typedef struct {
    int num;
} Cool;
Trl: Cool la ten moi kieu cau truc cach khai bao: Cool [ten_bien];

13. What are the different between i++ and ++i? What should we use?
Trl: i++; tang gía trị lên sau 1 đơn vị sau khi thực hiên lệnh
     ++i thực hiện tăng lên 1 đợn vị rồi mới thực hiện lênh 

14. Is calling free on the same address twice ok?
Trl: Không
 
15. Why do we need heap? Why can't a program just run on stack memory?
Trl: Trên vùng nhớ Stack mỗi biến hay hàm con điều theo nguyên tắc LIFO,
vd: co 3 biến int x,y,z; giả sử x năm cuối của stack y giữa và z nằm trêm đầu như vây nếu mún giải phóng x thì phải chờ z giả phóng trước,
trong con tro vùng nhớ duoc cap phat ở trong heap, no khong theo qui tac LIFO nen ham free() sẽ giải phóng trên vùng nhớ này.


16. How many bytes of memory are used to store a long long data type?
Trl: sizeof(long long) = 8 bytes;
 
17. What should the program below print?
    #include <stdio.h>
    #include <string.h>
    #include <stdlib.h>

    void myfunc(char** param) {
        ++param;
    }

    int main() {
        char* string = (char*)malloc(64);
        strcpy(string, "hello_World");
        myfunc(&string);
        myfunc(&string);
        printf("%s\n", string);
        // ignore memory leak for sake of quiz
        return 0;
    }
Trl: "hello_World" 

18. Compare the performance of 2 below program
    #include <stdio.h>
    int main() {
        printf("Hello, world!\n");
        return 0;
    }

    #include <stdio.h>
    int main() {
        printf("Hello, ");
        printf("world!\n");
        return 0;
    }
Trl: hieu suất của Ctr đầu tiên cao hơn Ctr sau.

19. What's wrong with this code?
    int a[5];
    for (i = 1; i <= 5; i = i + 1) {
        a[i] = 0;
    }
Trl: chưa khai báo biến i, mảng a khai báo 5 phần tử từ 0 - > 4;
nếu i = 5, tương ứng a[5] = 0; nhưng mảng tối đa chỉ từ a[0]->a[4], a[5] không thuộc quyền quản lý của Ctr.
- index out of bound
- nếu phần tử a[5] là phần tử mà Ctr khác đang chạy như vậy sẽ dẫn đến xung đột vùng nhớ.

20. Why some variable names for string start with "sz" (like szUserName)?
Trl: đại diện cho tên chuỗi kết thuc bằng ký tự NULL

21. Differentiate between /proc/mounts, /proc/1/mounts, /proc/self/mounts, /proc/self/mountinfo, /etc/mtab.
What should I use?

22. Read the following blogs/papers/wikis, explain what they are about?
    https://en.wikipedia.org/wiki/Linux_startup_process
Trl: quá trình khởi động Linux

    https://github.com/0xAX/linux-insides/tree/master/Booting
Trl: quá trình khởi động kernel 

23. Read the following blogs/papers/wikis, explain what they are about?
    https://markshroyer.com/2012/06/c-both-true-and-false/
Trl: khác nhau về quá trình xử lý giữa true và false trong Asm
    https://blogs.msdn.microsoft.com/oldnewthing/20171222-00/?p=97635
Trl: Hành động chưa được định nghĩa, xảy ra hiện tượng lạ.

24. What is the difference between a defining instance and an external declaration?
Trl: Nếu khai báo có từ khoá extern phía trước kiểu dữ liệu thì khi biên dich compiler sẽ hiểu là biến này được định nghĩa nơi khác
     Nó còn là tham chiếu của một biến cùng tên nào đó, đã được định nghĩa bên ngoài (Toàn Cục) 

     Ngược lại khao báo thông thường khi biên dich compiler sẽ cấp cho 1 vùng nhớ . 

25. Read the following blogs/papers/wikis, explain what they are about?
    https://blogs.msdn.microsoft.com/oldnewthing/20140627-00/?p=633

26. What is the problem with this piece of code?
    #include <stdio.h>
    #include <stdlib.h>
    int main(int argc, char* argv[]) {
        int a = atoi(argv[1]);
        int b = atoi(argv[2]);
        printf("%d\n", a / b);
    }
Trl: nếu không nhập đối số mà chỉ thực hiện lênh ./a.out thi sẽ báo lõi Segmentation fault (core dumped) 
vì nếu không có đối số thì con trỏ *argv[] không thể trỏ tới 1 vùng chưa tồn tại

27. What is a compilation unit?

28. What does this function do?
    https://github.com/mirror/busybox/blob/1121b4e568b340cfe2a9b7fc41fb48f4d684ad47/libbb/make_directory.c#L27
Trl: taọ thư muc mới.

29. What is the difference between angle bracket < > and double quotes " " while including header files in C?
trl: đối với <> khi biên dich compiler sẽ chép nội dung những head_file hệ thống vào.
còn với " " khi biên dịch compiler sẽ kiểm tra với những Header file trong thư viện riêng, nếu ko có sẽ kiểm tra đến những thư viện hệ thống. 


30. Read the source code of kill util and explain the functionality
    https://github.com/karelzak/util-linux/blob/c61e986fd0ab33731bbe2762a8a3168572f5a3ea/misc-utils/kill.c

31. What's wrong with this #define line?
    #define N 10;
Trl: không được thêm dấu ';' sao lênh #define

32. Suppose you defined the macro
    #define SIX 2*3
Then, suppose you used it in another expression:
    int x = 12 / SIX;
What value would x be set to?
Trl: lệnh x = 12 / SIX <=> x = 12/2*3; => x=18;

33. What will happen when we free a NULL pointer?
Trl: Hàm free() sẽ ko diễn ra trên con trỏ NULL;

34. If you can write a function by using a loop and using recursive and both of them are simple, which one should you choose?
Trl: chỉ khi nào vòng lặp không thực hiện được mới sử dụng đệ quy, vì đệ quy làm Ctr chạy chậm và tốn vùng nhớ trên Stack nhiều hơn.

35. When running the program below, the malloc statement will always be executed?
    #include <stdlib.h>
    #include <stdio.h>

    int* ptrToData;

    int main() {
        if (!ptrToData) {
            ptrToData = (int*)malloc(sizeof(int) * 10);
            printf("%p\n", ptrToData);
        }

        free(ptrToData);
        return 0;
    }
Trl: con tro ptrToData được khái báo global nên mặc định nó sẽ trỏ tới null, vì vậy 
if(!NuLL) sẽ lun được thỏa mảng khi thực Ctr.   
 
36. What number is output by the program below?
    #include <stdio.h>
    int main() {
        const char   firstname[] = "bobby";
        const char*  lastname = "eraserhead";
        printf("%lu\n", sizeof(firstname) +  sizeof(lastname));
        return 0;
    }
Trl: firstname là mảng nên sẽ có 1 ký tự '/0' để kết thúc 1 chuỗi ký tự => sizeof = 6byte;
     lastname là con tro nên sizeof => 8 byte.
=> Output = 14 bytes;

37. What should the program below print?
    #include <stdio.h>
    int main() {
        int x = 0;

        x = 10, 2 + 3, 4;
        printf("x = %i\n", x);

        x = (10, 2 + 3), 4;
        printf("x = %i\n", x);
    }
Trl: Mức độ ưu tiên giữa các toán tử, toán tử ',' có độ ưu tiên thấp nhất nên:
- x = 10,2 + 3,4; toán tử + có độ ưu tiên cao nhất trong TH này, vậy phép toán thực hiện đầu tiên là + <=> 2+3
=> x = 10,5,4 tiếp theo toán tử '=' sẽ thực hiện nên 10 sẽ đc gán cho x => x = 10;

- x = (10,2+3),4; Toán tử cặp () tăng độ ưu tiên nên phép toán trong () sẽ thực hiên đầu tiên nên
=> x = (10,5),4; tiếp tiếp theo (10, 5) sẽ được gán cho x vì độ ưu tiên của toán tử '=' cao hơn ',' nên x = (10,5);
vì giá trị bên phải toán tử ',' và cuối cùng  thi luôn được định trij là giá trị cuar toàn bộ biểu thức nên => x = 5;

38. Do we need coding standards?
Trl: có do người lập trình viết theo cách mã hóa riêng hoặc theo mã hóa định dạng chuẩn, điều này giúp cho việc bảo mật dữ liệu.

39. What is /lib/x86_64-linux-gnu/libc.so.6? Is it a shared or static library? What is its license?
Trl: - 
- nó là thư viện Shared library
- GNU

40. Why do we need struct? What problems does struct solve?
Trl: struct giúp chúng ta định nghĩa 1 kiểu dữ liệu mới.
Ex: 1 đối tượng có nhiều thành phần như 1 chiếc xe trong 1 chiếc xe gồm có: NSX, name, Type, brand,...
như vậy với 1 biến thông thương ta không thể định nghĩa được hết vì vậy ta cần struct.
struct giúp cập nhật dữ liệu dễ dàng hơn nhiều so với việc khai báo từng biến. 


41. Why do we need pointers? Why can't we just pass and return by value?
Trl: Con trỏ giúp cho những tác vụ trở nên linh hoạt hơn
vd: ta có 1 hàm 
void func(int a){a = 10;}
khi thuc thi ta cấp đối số cho hàm func(); là 1 biến int t = 0;
sao khi qua hàm func(t); thì t = 0; vì khi kết thúc hàm func() đồng nghĩa với việc ham fucn() đã được giải phóng trong stack
trong khi t vẫn còn nên t sẽ = 0;
điều này có nghĩa là ô nhớ chứa dữ liệu t là 0;  cho nên nếu mún thay đỗi giá trị t ta phải đi tới ô nhớ t,
vì vậy ta cần con trỏ -> ô nhớ t. t có hàm sao:
void func2(int *a){*a = 10;} thì khi cấp đối số t và thực thi ta thấy t = 10;
như vậy con trỏ giúp ta quản lý các ô nhớ, cũng như quản lí dữ liệu của từng ô nhớ.


42. What are /dev/sda, /dev/sda1, /dev/sda2?
Trl: 
- /dev/sda1 là phân vùng ổ cứng thông thường hệ điều hành sẽ cài ở đây.
- /dev/sda là dung lượng toàn ổ cứng
- /dev/sda2 là phân vùng thứ ổ cứng 

43. Is this code safe?
int cool(int* p) 
{
    if (p && *p) {
        return 1;
    }
    return 0;
}
Trl: kết quả trả về phụ thuộc vào dữ liệu của tham biến,  chỉ khi nào địa chỉ tham bien = 0, thi ket qua luon = 0;

44. What is the size of the following struct? Why does it work that way? How can we prevent that from happening?
struct Cool {
    char a;
    int b;
};
Trl: kích thước của struct là 8 bytes, vì theo Struct alignment:
ta có: compiler sẽ cấp 1 lần 4 bytes tương ứng kiểu dữ liệu lớn nhất trong struct, compiler sẽ ghi 1 byte A đầu tiên cho kiểu char lúc này con 3 bytes nhưng 3 byte này không thể chứa
được kiểu dữ liệu int nên 3 bytes sẽ được padding sao đó compiler sẽ cấp thêm 4 bytes nữa để chứa int.
Vì khi CPU truy cập không theo từng ô nhớ mà theo 1 nhóm ô nhớ có thể 2, 4 ,8 byte.
- Để tránh việc padding trong struct thì khi khái báo các biến trong Strutc nên xem kỹ đối tượng mô tả của Struct,
sắp xếp các biến có size_max trước hoặc cuối cùng KHÔNG đặt các biến có size nhỏ xen kẻ với size_max
vd: biến trong struct gồm có: {short a; char b; char d; short t;} => size = 6 bytes, padding byte = 0;


45. Describe the Linux process memory layout.
Print out a stack pointer. What is its location in the memory layout?
Trl: 
trong linux: Hệ thống Ram được phân chia như sau:
- trên cùng OS kernel Space (người sử dụng không thể đọc hoặc ghi đến vùng này)
- bên dưới là Stack (người sử dụng có thể đọc hoặc ghi tới vùng này), nguyên tắc LIFO
- tiếp theo là Heap (bộ nhớ động người dùng phải tự cấp phát, và phải giải phóng khi sử dụng)
- BSS là vùng  chứa các biến khi thực thi thì sẽ tạo ra.
- Data là vùng  chứa các biến tĩnh, và các biến toàn cục
- Text chứa các mã thực thi của 1 Ctr, chỉ có thể đọc

void pointer()
{
void *p = NULL;
printf("%p\n",(void*)&p);
}

- Trong Stack mõi hoạt động được diễn ra theo nguyên tắc LIFO, nghĩa là biến nào duoc khai bao trước thì khi ra khỏi Stack biến đó sẽ 
kết thúc cuối cùng.

46. Suppose we need to add 2 below int arrays.
    int a[4] = { 1,  2,  3,  4};
    int b[4] = {10, 20, 30, 40};
For a fast add operation, we will use _mm_add_epi32 function. However, this function needs both of its args have alignment of 16.
How can we do that?
Trl: Add #include <stdalign.h>
    alignas(16) int a[4] = { 1,  2,  3,  4};
    alignas(16) int b[4] = {10, 20, 30, 40};

47. What do these programs do? Does they have any problem/bug in the code?
https://bitbucket.org/so61pi/examples/src/f1b02bdac0ff79663117d29006f0495fc5074b5c/Others/ZlibExample.cpp
https://bitbucket.org/so61pi/examples/src/f1b02bdac0ff79663117d29006f0495fc5074b5c/Others/ComplexityGuess.cpp
https://bitbucket.org/so61pi/examples/src/f1b02bdac0ff79663117d29006f0495fc5074b5c/Others/LibpngExample.cpp
https://bitbucket.org/so61pi/examples/src/f1b02bdac0ff79663117d29006f0495fc5074b5c/Others/QuickSort.cpp
https://bitbucket.org/so61pi/examples/src/f1b02bdac0ff79663117d29006f0495fc5074b5c/Linux/FileMapping.cpp
https://bitbucket.org/so61pi/examples/src/f1b02bdac0ff79663117d29006f0495fc5074b5c/Linux/DaemonizeProcess.cpp
https://bitbucket.org/so61pi/examples/src/f1b02bdac0ff79663117d29006f0495fc5074b5c/Linux/GetFileStat.cpp
https://bitbucket.org/so61pi/examples/src/f1b02bdac0ff79663117d29006f0495fc5074b5c/Linux/ListRunningProcesses.cpp
https://bitbucket.org/so61pi/examples/src/f1b02bdac0ff79663117d29006f0495fc5074b5c/Linux/RawSocket.cpp
https://bitbucket.org/so61pi/examples/src/f1b02bdac0ff79663117d29006f0495fc5074b5c/Linux/LibSSH2Example.cpp
https://bitbucket.org/so61pi/examples/src/f1b02bdac0ff79663117d29006f0495fc5074b5c/Architecture/SSE.cpp

48. In gcc, there are several sanitizer (e.g. AddressSanitizer, LeakSanitizer)? What are their functionalites?
Use them to identify the bug of the following program

    #include <stdlib.h>
    #include <stdio.h>

    void cool(int* a) {
        int size = *a;
        ++a;
        for (int i = 0; i < size; ++i) {
            printf("%d ", a[i]);
        }
        free(a);
    }

    int main() {
        int* a = (int*)malloc((1 + 9) * sizeof(int));
        a[0] = 9;
        for (int i = 1; i < 10; ++i) {
            a[i] = i;
        }
        test(a);
        free(a);
    }
Trl: 
- AddressSanitizer là công cụ dùng để kiểm tra lỗi trông bộ nhớ như tràng bộ đệm, hoặc truy cặp đến con trỏ đã giải phóng
- LeakSanitizer dùng để kiểm tra rò rỉ trong bộ nhớ
$ clang -fsanitize=address -g [name].c
$ ./a.out
-> BUG: test(a);

49. When you see a pointer in code, how can you know that
    - It cannot be NULL. -> kiểm tra giá trị con trỏ nếu giá trị con trỏ = 0; => con trỏ NULL
    - It points to a heap mempry or stack memory. -> thông thường ko thể kiểm tra vị trí con trỏ năm trên stack hay heap
    - You need to free it after use.-> nếu con trỏ sử dụng hàm cấp phát thì phải giải phóng, nếu là con trỏ bình thường thì ko cần

50. What is a reentrant function? Is it a good thing or bad thing?
Trl: Reentrant function nó dùng để ngắt các chức năng trong quá trình thực thi, sao đó tiếp các chức năng khác, mà ko làm 
gián đoạn các chức năng trước đó.
- Trông các IC nhúng thì không nên sử reentrant function, thông thường thì RAM của VDK rất nhỏ, nên khi sử dung reentrant function
có thể gây ra Tràng stack;

51. What is a pure function? Is it a good thing or bad thing?
Trl: pure function là 1 hàm thuần khuyết không phụ thuộc và không bị thay đổi trạng thái vào các biến ngoài phạm vi của nó.
-lợi ích: chỉ quan tâm đến Input và Output

52. Where is errno defined?
Trl: #include <errno.h>

53. Why do we need free in C? Why do some other languages (like Java) don't have a similar function to free?
Trl: Vì trong C có các hàm cấp phát con trỏ, vì con trỏ sao khi cấp phát nó ở Heap nên khi sử dụng xong phải free(), để trả lại
vùng nhớ cho hệ điều hành khi đã sử dụng xong. 
Trên java không có khái niệm con trỏ, chỉ có biến tham chiếu.

54. How much memory can an x86-64 program have?
Trl: 2^48.

55. What is symlink? How does it differ from hardlink?
Trl: symlink là 1 file liên kết tượng trưng tro đến file gốc
- Symlink bị xóa ko ảnh hưởng đến file gốc
- Xóa file gốc, symlink sẽ mất giá trị
- create: ln -s /Path/ [name]

56. How does makefile speed up compiling process? Does it work the same way as ccache?
Trl: make -j N
- khi biên dich makefile lần đầu tiên thì compipler sẽ biên dịch tất cả các file có trong makefile 
- sau khi chĩnh sữa ở đâu đó 1 file trong makefile thì compipler chỉ biên dịch file đã chĩnh sữa như vậy làm tăng nhanh thời gian biên dịch

57. By default, the gcc compiler uses a default debug level? What is it? How can we change it?
Trl: Defauld gcc debug ở mức -g, nó dùng để gở lỗi, có thể thay đõi mức debug bằng cách -gn với n = {0,1,2,3} 

58. Sometime, the output program/library built by gcc is not stipped which make its size larger than normal.
How can we strip the file to make it smaller?

Trl: reduce the size of file

59. What does function gethostbyname do? Is that function thread-safe?
trl: lấy host name và địa chỉ IPv4. 
- Có

60. Why do we need page-table? Is it related to virtual memory or physical memory?
trl:page-table là cấu trúc dữ liễu sử dụng hệ thống bộ nhớ ảo của hệ điều hành.
- page table được lưu trong bộ nhớ chính
- page-table nó ánh xạ từ địa chỉ ảo đến địa chị vật lý. 
- Vì trong bộ nhớ có các farm, OS sẽ quản lý các farm trống, trong bộ nhớ logic cũng có các khối có cùng kich thướt gọi là page
- để có thể chạy Ctr có size n page thì phải tìm các n farm còn trống, 
vì vậy nên sẽ cần đến các page-table để chuyển các địa chỉ logic thành các địa chỉ thực. 

61. Compile a program with -g0 and -g3. Run them in gdb and try to debug step by step.
-Trl: 


62. Why do we need ASLR? In Linux, how can it be turned off?
Trl: ASLR là bản vá của kernel nhầm tránh các Ctr độc hại lợi dụng 
- Turned off: sysctl -w kernel.randomize_va_space=0

63. The following code snippet is from Linux kernel 2.6.30
    static unsigned int tun_chr_poll(struct file *file, poll_table * wait)
    {
        struct tun_file *tfile = file->private_data;
        struct tun_struct *tun = __tun_get(tfile);
        struct sock *sk = tun->sk;
        unsigned int mask = 0;
    
        if (!tun)
            return POLLERR; 

Is there any problem with it?
(You can find the whole function here: https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/tree/drivers/net/tun.c?h=v2.6.30#n485)

64. We have autility that copy file, below is its source code.
    #include <stdio.h>
    #include <stdlib.h>

    int main(int argc, char* argv[]) {
        if (argc != 3) {
            printf("Usage: %s <soure-file> <target-file>\n", argv[0]);
            return EXIT_FAILURE;
        }

        char const* source_file = argv[1];
        char const* target_file = argv[2];
        char ch;
        FILE *source, *target;

        source = fopen(source_file, "r");
        if (source == NULL) {
            perror("fopen");
            return EXIT_FAILURE;
        }

        target = fopen(target_file, "w");
        if (target == NULL) {
            perror("fopen");
            fclose(source);
            return EXIT_FAILURE;
        }

        while ((ch = fgetc(source)) != EOF) {
            fputc(ch, target);
        }

        fclose(source);
        fclose(target);
        return 0;
    }
Usually it works fine. But when users copy a large file and then cancel the copying by pressing Ctrl+C,
the target file still have partial copied data. The users want that when they cancel the copying, the
target file should not be there.
To solve this problem, a programmer suggests that we could use the signal handler. Please take time to
research this and propose a solution.

TrL: Add #include <signal.h>
- sử dụng ngắt handler SIGINT

65. Distinguish between mutex and semaphore.
trl: 
- cả mutex và semaphore điều là dùng để quản lý việc truy xuất của những quá trình tới 1 tài nguyên.

-> Mutex dùng để ngăn chặn việc 2 task accept đến 1 tài nguyên.
vd: Giả sử có 1 file. task_1 có nhiệm vụ là đọc file, taske_2 có nhiệm vu là ghi file. Nếu task_1 đang đọc file mà cùng lúc task_2 cũng ghi đè vào file
lỡ như task_1 chưa đọc xong mà task_2 ghi vào thì sẽ dẫn đến việc sai lệch dữ liệu mà task_1 đang thực hiện.

-> Semaphore là bản nâng cấp của mutex nếu mutex chỉ ở process thì ở Semaphore sẽ là multiprocess



66. Below is the source code that contains doxygen comments.emaphore
https://bitbucket.org/so61pi/examples/src/f1b02bdac0ff79663117d29006f0495fc5074b5c/Others/DoxygenExample.cpp
Please help to generate the document from that file by using doxygen tool.

-> doxygen -g [name]

II. Functions
1. Write a function that swaps 2 int variables.
2. Write a function that never returns.
3. Write a function that moves a memory area to another place.
4. Write a function that receives an array as an argument, and return a different array.


III. Applications
1. Write a program that prints all its arguments and environment variables.
Create a symlink to your program and run it. Explain the different of the outputs.

2. Write a program that copys file content to another location.
3. Write a program that lists content of a directory.
4. Write a program that lists content of a directory recursively.
5. Write a program that prints current month in this format
December 27     2017
SU MO TU WE TH FR SA
                1  2 
 3  4  5  6  7  8  9 
10 11 12 13 14 15 16 
17 18 19 20 21 22 23 
24 25 26 27 28 29 30 
31

6. Write a program that prints out first N fibonacci numbers. N is the input from users.
7. Write a program that print a random number? Is you random function uniform distributed?
8. Write a program that computes the average of first N fibonacci numbers. N is the input from users.
9. In Linux, the /proc/self/mountinfo contains the system mount information a particular process can see.
Write a program that check if a directory is a mountpoint base on the content of /proc/self/mountinfo.

10. Write a program that lists all running processes in the system with their PID.
11. Write a program that lists the content of a directory of an FTP server.
12. Write a program that checks the latency between a client and a server? ICMP shoud be used as it is a standard protocol.
No external library should be used.

13. Write a program that prints out the SHA1 of a file. We could use openssl library.
14. Write a program that prints out the size of free memory in the system.
15. Implement TWAMP protocol.
16. Implement a SNMP module for NetSNMP.
17. Write a simple web server that serves a specific directory by using Mongoose Embedded Web Server Library.
Can we use this web server in closed-source project?

18. Currently we have an echo server that send back any message it receives from clients.
The problem is it can only serve one client at a time. We need a solution that can scale up to ~1000 clients.
Please propose your solutions with the implementations.

19. We need to write a hex viewer. It should be able to open any file despite of the file size.
The current implemetation reads the whole file to memory. This works fine for small files but
it take a very long time to open very big files (>1GB). The internet suggest that we could use
mmap function. Please take some time to research that function, then implement your solution
to solve our problem here. 

20. Implement the behavior of virtual function of C++ in C.
#include <iostream>

class Base {
public:
    virtual void show(char const* msg) = 0;
};

class Derived : public Base {
public:
    virtual void show(char const* msg) {
        std::cout << msg << std::endl;
    }
};

21. Recently we've added a new daemon in our embedded system and it's been working very well. There is only small problem that sometime it uses too much memory,
the kernel has to kill it. We need to limit the maximum memory it can use. Please provide a solution for this.

22. Write a hello world kernel module.
23. Write an application that starts another application.

24. Currently we have a system that consists several clients and one server.
Each client sends a very large data to the server. The server processes
that data and send back the result to the corresponding client.

The problem is the server can only process data from 4 clients at a time
but currently there are no mechanism to prevent that.

What we want is the server can receive data from 20 clients concurrently
but only process 4 data.

A programmer suggests that in the server, we should have 5 threads. The
main thread is for accepting connections and receiving data from clients.
Each of the other 4 threads will process data and send back result to the
main thread to send to clients.

Please help to research the solution and implement a prototype. The data
sent from client should be a file. The server will calculate the SHA1 of
the data and send it back to clients.


IV. Building/Compiling
1. Build a linux kernel from source.
https://www.kernel.org/

2. Create an image with rootfs. Test it with QEMU.
